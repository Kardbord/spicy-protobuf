module protobuf;

import spicy;

# message := (tag value)*
#     A message is encoded as a sequence of zero or more pairs of tags and values.
public type Message = unit {
    first_tag: TagAndValue;
    the_rest: bytes &eod;
    #message: TagAndValue[] &eod;

    on %done {
        print self;
    }
};

type WireType = enum {
    VARINT = 0x00,
    I64    = 0x01,
    LEN    = 0x02,
    SGROUP = 0x03, # deprecated
    EGROUP = 0x04, # deprecated
    I32    = 0x05
};

type TagAndValue = unit {
    tag:   Tag;
    value: Value(self.tag);
};

# tag := (field << 3) | wire_type
#     A tag is a combination of a wire_type, stored in the least significant three bits,
#     and the field number that is defined in the .proto file.
#     Encoded as uint32 varint.
# Example:
#   In the protobuf_udp_addressbook.raw file, the top level message is a repeated field with
#   a field number of 1. Therefore the tag would be 00001010.
#   [0]0001010 : continuation bit
#   0[0001]010 : varint payload, aka field number
#   00001[010] : wire type (2, which is wire type LEN)
type Tag = unit {
    data: bitfield(8) {
        ignore: 0;
        field_number: 1..4;
        wire_type: 5..7 &convert=WireType($$);
    } &bit-order=spicy::BitOrder::MSB0;
    # TODO
};

# value := varint      for wire_type == VARINT,
#          i32         for wire_type == I32,
#          i64         for wire_type == I64,
#          len-prefix  for wire_type == LEN,
#          <empty>     for wire_type == SGROUP or EGROUP
#     A value is stored differently depending on the wire_type specified in the tag.
type Value = unit(tag: Tag) {
    switch(tag.data.wire_type) {
        WireType::VARINT -> var_int : VarInt;
        WireType::I32    -> i32     : I32;
        WireType::I64    -> i64     : I64;
        # TODO - Finish switch for other types
    };
};

# varint := int32 | int64 | uint32 | uint64 | bool | enum | sint32 | sint64
#     Encoded as varints (sintN are ZigZag-encoded first).
type VarInt = unit {
    data: VarIntOctet[] &until-including=(!($$.data.continuation_bit));
};

type VarIntOctet = unit {
    data: bitfield(8) {
        continuation_bit: 0;
        payload: 1..7;
    } &bit-order=spicy::BitOrder::MSB0;
    on %done {
        print "Continuation Bit: %d; little-endian payload: %d" %(self.data.continuation_bit, self.data.payload);
    }
};

# i32 := sfixed32 | fixed32 | float
#     Encoded as 4-byte little-endian.
#     memcpy of the equivalent C types (u?int32_t, float)
type I32 = unit {
    # TODO
};

# i64 := sfixed64 | fixed64 | double
#     Encoded as 8-byte little-endian.
#     memcpy of the equivalent C types (u?int64_t, double)
type I64 = unit {
    # TODO
};

# len-prefix := size (message | string | bytes | packed)
#     A length-prefixed value is stored as a length (encoded as a varint), and then one
#     of the listed data types.
#     Size encoded as int32 varint
type LenPrefix = unit {
    # TODO
};

# string := valid UTF-8 string (e.g. ASCII)
#     As described, a string must use UTF-8 character encoding. A string cannot exceed 2GB.
type String = unit {
    # TODO
};

# bytes := any sequence of 8-bit bytes
#     As described, bytes can store custom data types, up to 2GB in size.
type Bytes = unit {
    # TODO
};

# packed := varint* | i32* | i64*
#     Use the packed data type when you are storing consecutive values of the type described
#     in the protocol definition. The tag is dropped for values after the first, which
#     amortizes the costs of tags to one per field, rather than per element.
type Packed = unit {
    # TODO
};
