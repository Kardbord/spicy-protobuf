module protobuf;

import spicy;

# message := (tag value)*
#     A message is encoded as a sequence of zero or more pairs of tags and values.
public type Message = unit {
    first_field: TagAndValue;
    the_rest: bytes &eod;
    #message: TagAndValue[] &eod;

    on %done {
        print self;
    }
};

type WireType = enum {
    VARINT = 0x00,
    I64    = 0x01,
    LEN    = 0x02,
    SGROUP = 0x03, # deprecated
    EGROUP = 0x04, # deprecated
    I32    = 0x05
};

type TagAndValue = unit {
    tag:   Tag;
    value: Value(self.tag);
};

# tag := (field << 3) | wire_type
#     A tag is a combination of a wire_type, stored in the least significant three bits,
#     and the field number that is defined in the .proto file.
#     Encoded as uint32 varint.
# Example:
#   In the protobuf_udp_addressbook.raw file, the top level message is a repeated field with
#   a field number of 1. Therefore the tag would be 00001010.
#   [0]0001010 : continuation bit
#   0[0001]010 : varint payload, aka field number
#   00001[010] : wire type (2, which is wire type LEN)
type Tag = unit {
    field_num: VarInt;
    wire_type: uint64 &convert=WireType($$) if (False);

    on %done {
        # Last three bits are wire type
        self.wire_type = WireType(self.field_num.data & 0x07);
        # Upper bits are field number
        self.field_num.data = self.field_num.data >> 3;
    }
};

# value := varint      for wire_type == VARINT,
#          i32         for wire_type == I32,
#          i64         for wire_type == I64,
#          len-prefix  for wire_type == LEN,
#          <empty>     for wire_type == SGROUP or EGROUP
#     A value is stored differently depending on the wire_type specified in the tag.
type Value = unit(tag: Tag) {
    switch(tag.wire_type) {
        WireType::VARINT -> varint  : VarInt;
        WireType::I32    -> i32     : I32;
        WireType::I64    -> i64     : I64;
        # TODO - Finish switch for other types
    };
};

function parse_varint(buf: vector<uint8>) : uint64 {
    local parsed: uint64 = 0;
    local temp: uint64 = 0;
    while (local i = 0; i < |buf|) {
        # Drop continuation bit
        temp = buf[i] & 0x7F; # Drop continuation bit
        # Convert to big-endian
        parsed = parsed | (temp << (i * 7));
        ++i;
    }
    return parsed;
}

# varint := int32 | int64 | uint32 | uint64 | bool | enum | sint32 | sint64
#     Encoded as varints (sintN are ZigZag-encoded first).
type VarInt = unit {
    data: uint8[] &until-including=($$ < 0x80) &convert=parse_varint($$);
};

# i32 := sfixed32 | fixed32 | float
#     Encoded as 4-byte little-endian.
#     memcpy of the equivalent C types (u?int32_t, float)
type I32 = unit {
    # TODO
};

# i64 := sfixed64 | fixed64 | double
#     Encoded as 8-byte little-endian.
#     memcpy of the equivalent C types (u?int64_t, double)
type I64 = unit {
    # TODO
};

# len-prefix := size (message | string | bytes | packed)
#     A length-prefixed value is stored as a length (encoded as a varint), and then one
#     of the listed data types.
#     Size encoded as int32 varint
type LenPrefix = unit {
    # TODO
};

# string := valid UTF-8 string (e.g. ASCII)
#     As described, a string must use UTF-8 character encoding. A string cannot exceed 2GB.
type String = unit {
    # TODO
};

# bytes := any sequence of 8-bit bytes
#     As described, bytes can store custom data types, up to 2GB in size.
type Bytes = unit {
    # TODO
};

# packed := varint* | i32* | i64*
#     Use the packed data type when you are storing consecutive values of the type described
#     in the protocol definition. The tag is dropped for values after the first, which
#     amortizes the costs of tags to one per field, rather than per element.
type Packed = unit {
    # TODO
};
